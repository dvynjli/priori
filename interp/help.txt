Q. Do we need variable in env for all SSA variables?
A. Yes. Otherwise we need to do computation on source program, which require making a c++ parser.

Q. Load and AtomicLoad (and store) can be handled same way?
A. From Apron point of view - yes, 
    from Z3 - yes
    from static analyzer - no (race detection)

Q. How to handle interferences of a thread with itself if more than one instance of a thread is executing?
A. Not handling as of now. Multiple threads of a function are not supported.

Q. What to do for loops?
A. Can do manual unrooling. Will think about implementing support for widening and narrowing later

Q. What to do for function arguments?
A. Ignoring for now. Not to hard to add support for this

Q. Can we work with computing possible interferences ones? Is there a way for these interferneces to change
A. We can work with computing feasible interfernces ones before starting thread-modular analysis. 
    All possible interferences are fixed since loads and stores of global variables can not change (assuming no pointers).
    Feasiblity of these interferences depends upon memory order, program order and happens before relations,
    which can not change mid-analysis.


Instructions that need Apron interface-
    BinOp   +, -, *, /, %, &&, ||, rmw, 
            &, | (can be added later)
    UnaryOp !, load, store
            -, ~ (can be added later)
    CmpXchg
    Function calls (can be added later)
Instructions that need Z3 interface-
    thread create, thread join, fences, lock,

TODO:
    init local vars with TOP, not zero
    check how to merge environments from two different iteration (due to different interferences)
    get load store pairs only ones (from initThreadDetails) - 
        need to stop analysis if load reads from a store that is unreachable so far (should not be in domain map)
        can optimize this
    if a function has no loads, it will have no interferences, and will never be analyzed
    Join domains after analysis and add to programState map


Race detection on non-atomics - if a non aomic load can read from more than one writes



Possible Optimizations:
    don't support thread creation from functions other than main()
        reduced one pass over program
    Reduce number of maps (if maps are taking too much time):
        run a pass to give instr id to each intruction and store the environment of the intructions in this order or make a wrapper around Instructions


    parallelization
        checking feasiblity of interfernces with analysis of other thread
        analysis of all threads for 1 iteration
    
export CPLUS_INCLUDE_PATH=/home/divyanjali/.opam/system/share/apron/include/
export LIBRARY_PATH=/home/divyanjali/.opam/system/share/apron/lib/
export LD_LIBRARY_PATH=/home/divyanjali/.opam/system/share/apron/lib/